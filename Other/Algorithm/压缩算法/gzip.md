## 算法说明

> [LZ77](https://www.cnblogs.com/en-heng/p/4992916.html)
>
> [LZ77简介](https://blog.csdn.net/weixin_30654583/article/details/95064293)
>
> [数据压缩算法---LZ77算法 的分析与实现 ](https://www.cnblogs.com/idreamo/p/9249367.html)
>
> [数据压缩的重要组成部分---位操作 ](https://www.cnblogs.com/idreamo/p/9153691.html)
>
> [Huffman](https://www.cnblogs.com/kuang17/p/7193124.html#:~:text=gzip,%E5%AF%B9%E4%BA%8E%E8%A6%81%E5%8E%8B%E7%BC%A9%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E9%A6%96%E5%85%88%E4%BD%BF%E7%94%A8LZ77%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8F%98%E7%A7%8D%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9%EF%BC%8C%E5%AF%B9%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E5%86%8D%E4%BD%BF%E7%94%A8Huffman%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%AE%9E%E9%99%85%E4%B8%8Agzip%E6%A0%B9%E6%8D%AE%E6%83%85%E5%86%B5%EF%BC%8C%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81Huffman%E7%BC%96%E7%A0%81%E6%88%96%E8%80%85%E5%8A%A8%E6%80%81Huffman%E7%BC%96%E7%A0%81%EF%BC%8C%E8%AF%A6%E7%BB%86%E5%86%85%E5%AE%B9%E5%9C%A8%E5%AE%9E%E7%8E%B0%E4%B8%AD%E8%AF%B4%E6%98%8E%EF%BC%89%E8%BF%9B%E8%A1%8C%E5%8E%8B%E7%BC%A9%E3%80%82)
>
> [RFC-1952 GZIP 文件格式规范版本](https://www.rfc-editor.org/rfc/rfc1952)

以下内容取自中[algorithm.doc](ftp://prep.ai.mit.edu/pub/gnu/gzip/gzip-1.12.tar.gz)

zip和gzip使用的压缩算法是Lempel-Ziv 1977 [LZ77]的变体。它在输入数据中查找重复的字符串。 字符串的第二次出现被替换为指向前一个字符串的指针，形式为一对 (distance,length)。 距离限制为 32K 字节，长度限制为 258 字节。 当一个字符串在之前的 32K 字节中没有出现时，它会作为文字字节序列发出。 （在此描述中，'string' 必须被视为任意字节序列，并且不限于可打印字符。）

文字或匹配长度用一棵哈夫曼树压缩，匹配距离用另一棵树压缩。 树以紧凑的形式存储在每个块的开头。 块可以有任何大小（除了一个块的压缩数据必须适合可用内存）。 当 zip 确定用新树开始另一个块是有用的时，一个块就会终止。 （这有点类似于压缩。）

使用哈希表找到重复的字符串。 所有长度为 3 的输入字符串都被插入哈希表中。 为接下来的 3 个字节计算哈希索引。 如果该索引的散列链不为空，则将链中的所有字符串与当前输入字符串进行比较，并选择最长的匹配项。

从最近的字符串开始搜索散列链，以支持小距离，从而利用霍夫曼编码。 散列链是单链接的。 哈希链中没有删除，算法只是丢弃太旧的匹配项。

为了避免最坏的情况，很长的散列链被任意截断到一定长度，由运行时选项（zip -1 到 -9）决定。 所以 zip 并不总能找到可能的最长匹配，但通常会找到足够长的匹配。

zip 还延迟了具有惰性评估机制的匹配项的选择。 找到长度为 N 的匹配项后，zip 会在下一个输入字节处搜索更长的匹配项。 如果找到更长的匹配项，则先前的匹配项被截断为一个长度（从而产生单个文字字节），然后发出更长的匹配项。 否则，保留原始匹配，仅在 N 步后尝试下一个匹配搜索。

惰性匹配评估也受制于运行时参数。 如果当前匹配足够长，zip 会减少对更长匹配的搜索，从而加快整个过程。 如果压缩率比速度更重要，zip 会尝试进行完整的第二次搜索，即使第一次匹配已经足够长。

对于最快的压缩模式（速度选项 -1 到 -3）不执行惰性匹配评估。 对于这些快速模式，仅当未找到匹配项或匹配项不太长时，才将新字符串插入到哈希表中。 这降低了压缩率，但节省了时间，因为插入和搜索都更少了。

## gzip的源码说明

https://blog.csdn.net/hguisu/article/details/7795435

> [C实现gzip的压缩与解压](https://blog.csdn.net/moxiaomomo/article/details/52385837)