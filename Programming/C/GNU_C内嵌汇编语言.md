# GNU C 内嵌汇编语言

```c
#define nop() __asm__ __volatile__ ("nop     \n\t")
```

`__asm__`是关键词asm的宏定义（`#define __asm__`）

`__volatile`是告诉编译器，此行不能被优化，保持原状



## 内嵌汇编表达式

格式：**指令部分:输出部分:输入部分:损坏部分**

指令部分是函数中的代码，输入部分是向函数传递的参数，输出部分是函数的返回值，

### 指令部分

1. 若果表达式存在多条汇编代码，可全部书写在一或多对双引号种；如果是一对，相邻俩条用分号`;`或换行符和制表符`\n\t`分隔
2. 引用寄存器时，再添加一个`%`,例如`movl $0x10,%%eax`

### 输出部分

格式：**"输出约束" (输出表达式),"输出约束" (输出表达式),.......**

注：输出约束 输出表达式,需要成对出现。其中，输出表达式通常是一个表量。

输出约束使用`=`或`+`修饰，+用于输出和输入操作，=是输出操作。

### 输入部分

格式：**"输入约束" (输出表达式),"输入约束" (输出表达式),.......**

注：输入约束 输入表达式,需要成对出现

不允许使用`=`和`+`

### 损坏部分

格式：**"损坏描述","损坏描述",...**

#### 寄存器修改通知

```assembly
__asm__ __volatile__ ("movl %0,%%ecx"::"a"(__tmp):"cx");
```

修改了寄存器ECX的值，但没有任何输入输出记录，那么需要在损坏部分描述。

#### 内存修改通知

如果一个内嵌汇编语句修改了内存数据；或者内存数据可能发生改变，且被修改的内存没有使用m约束，应该在损坏募部分使用`memory`向声明内存会发生改变。防止内存与寄存器副本的数据不一致。

#### 标志寄存器修改通知

内嵌汇编表达式包含寄存器`R|EFLAGS`指令时，损坏部分使用`cc`

## 操作约束和修饰符

输入输出表达式都必须指定**操作约束**。

操作约束细分为寄存器约束、内存约束、立即数约束。输出表达式中还有限定寄存器的修饰符。

### 寄存器约束

寄存器约束的载体是寄存器，可以明确指定，也可以模糊指派。

```c
__asm__ __ volatile__ ("movl %0,%%cr0"::"eax"(cr0));
__asm__ __ volatile__ ("movl %0,%%cr0"::"a"(cr0));
```



| 缩写 |              描述               |
| :--: | :-----------------------------: |
|  r   |      任何输入输出的寄存器       |
|  q   | 从EAX/EBX/ECX/EDX指派一个寄存区 |
|  g   |      寄存器空间或内存空间       |
|  m   |            内存空间             |
|  a   |    使用RAX/EAX/AX/AL的寄存器    |
|  b   |    使用RBX/EBX/BX/BL的寄存器    |
|  c   |    使用RCX/ECX/CS/CL的寄存器    |
|  D   |    使用RDX/EDX/DX/DL的寄存器    |
|  S   |     使用RDI/EDI/DI的寄存器      |
|  f   |     使用RSI/ESI/SI的寄存器      |
|  i   |      一个整数类型的立即数       |
|  F   |     一个浮点数类型的立即数      |
|      |                                 |

### 内存约束

内存约束的载体是内存空间,使用m

```c
__asm__ __ volatile__ ("sgdt %0":"=m"(__gdt_addr)::);
__asm__ __ volatile__ ("lgdt %0":"m"(__gdt_addr)::);
```

### 立即数的约束

立即数约束只能用于输入部分，并表达式载体是一个数字

```c
__asm__ __volatile_- ("movl %0,%%ebx"::"i"(50));
```

### 修饰符

修饰符只能用在输出部分，除了`=`和`+`还有`&`。只能位于前二者之后。

`&`作用：告诉编译器不能为输入操作表达式分配该寄存器。