# 重定向

shell中

```纯文本
0表示标准输入
1表示标准输出
2表示标准错误输出
\> 默认为标准输出重定向，与 1> 相同
2>&1 意思是把 标准错误输出 重定向到 标准输出.
&>file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中
```

不输出 标准输出

```bash
1> /dev/null
```

不输出 标准错误输出

```bash
2> /dev/null
```

静默输出

```bash
>/dev/null 2>&1
```

将所有输出，重定向到文本

```bash
>test.txt 2>&1
```

用例子说话：

1.  grep da \* 1>&2
2.  rm -f \$(find / -name core) &> /dev/null
    上面两例中的 & 如何理解，&不是放到后台执行吗?

牛解：

1.&>file或n>\&m均是一个独立的重定向符号，不要分开来理解。

2.明确文件和文件描述符的区别。

3.&>file表示重定向标准输出和错误到文件

例如：
rm -f \$(find / -name core) &> /dev/null，/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。
4.n>\&m表示使文件描述符n成为输出文件描述符m的副本。这样做的好处是，有的时候你查找文件的时候很容易产生无用的信息,如:2> /dev/null的作用就是不显示标准错误输出；另外当你运行某些命令的时候,出错信息也许很重要,便于你检查是哪出了毛病,如:2>&1
