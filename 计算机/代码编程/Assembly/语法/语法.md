# 语法

## 目录

-   [基本概念](#基本概念)
-   [定义数据](#定义数据)
-   [寄存器](#寄存器)
-   [标志位](#标志位)
-   [算术](#算术)
-   [位](#位)
-   [字符串](#字符串)
-   [对比](#对比)
-   [循环](#循环)
-   [跳转](#跳转)
-   [函数](#函数)
-   [占位](#占位)
-   [IO端口](#IO端口)

# 基本概念

-   保留字

    具有特殊用途的字词，比如MOV（代表一条指令），不能单作变量和其他用途，不区分大小写，
-   标志符

    程序员定义的名词，用来表示变量，常量、过程等
-   命令

    命令是与指令集无关的一些操作，可以指挥汇编器去做某件事，例如定义变量、指明内存段等
-   段

    是用相关命令所标出的特殊段落。汇编器预先定义了几种这样的段落。NASM中，`SELECTION .bss`表示未初始化的变量，`SECTION .data`表示已初始化的变量，`SECTION .text`可执行的代码/指令
-   指令

    是程序中的可执行语句
-   字面值
    -   整数字面值
        | 基数  | 进制   | 示例        | 注意                       |
        | --- | ---- | --------- | ------------------------ |
        | b   | 二进制  | 00011111b |                          |
        | d   | 十进制  | 31,31d    |                          |
        | h   | 十六进制 | 1Fh       | 建议0开头，不如从A-F开头，可能会被单作标志符 |
        | q,o | 八进制  | 37o       |                          |
    -   字符字面值

        `"a"` 或`'A'`都是有效的
    -   字符串字面值

        说明：以BYTE（字符）数组的方式存储，需要null结尾,NASM中需要以0来设置最后一个字节

        格式：
        ```6502&#x20;assembly
        motd: DB "This string \"contains\" dobule quotes!",0
        ```
-   符号
    -   \[]

        作用：`[...]` 表示要操作的是内存地址，而不是直接操作寄存器。
        ```6502&#x20;assembly
        mov word [bp+4], 20
        ;[bp+4] 表示以基址指针（BP）为基址，偏移量为4的位置，将值20存储到该内存位置。
        ```
    -   \$

        \$表示表示当前行被编译后的地址。

        `JMP $`表示死循环，十六进制机器码是E9FDFF。E9表示跳转，EDFF确定跳转地址。x86是小端模式保存，所以地址偏移地址是0xfffd，即-3。这条指令长度为3个字节,所以会跳转到JMP前。执行后，再跳转。
    -   \$\$

        \$\$表示Section（节）初始处被编译后的地址。Section既可以是数据段，也可以是代码段，而不是函数。

        `$-$$`表示本行程序距离Section起始处的偏移。

# 定义数据

根据数据长度来确定数据，高级语言根据数据内容来确定数据类型。

-   长度类型
    | 初始化命令 | 未初始化方式 | 长度    | 备注    |
    | ----- | ------ | ----- | ----- |
    | DB    | RESB   | 1个字节  | byte  |
    | DW    | RESW   | 2个字节  | word  |
    | DD    | RESD   | 4个字节  | dword |
    | DQ    | RESQ   | 8个字节  | qword |
    | DT    | REST   | 10个字节 | tword |
-   定义格式
    -   一般格式
        ```bash
        标志符: 命令 初始化器 [,初始化器]...
        ```
    -   初始化定义方式
        ```bash
        wageArray: DD 75,100,125
        ```
    -   对于未初始化的变量

        NASM需要放入.bss段中,示例如下
        ```6502&#x20;assembly
        SECTION .bss
        memAddr: RESD 1  ;Reserves 1 DWORD (4 bytes)
        buffer:  RESB 64 ;Reserver 64 bytes
        ```
-   常量/符号常量

    说明： 用以表示程序执行期间绝对不会变化的值
    -   格式
        ```6502&#x20;assembly
        identifier: EQU expression ; numeric operations
        identifier: EQU 0          ; a single value(constant)
        identifier: EQU "text"     ; text can be four characters max(32-bit)
        ```
-   赋值

    定义常量
    ```6502&#x20;assembly
    BaseOfStack  equ  0x7c00 ;定义常量
    ```
    赋值方向从右到左
    ```纯文本
    ADD 目的操作数，源操作数
    ```

# 寄存器

-   通用目的寄存器(Genernal Purpose Register)
    | 64位    | 32位 | 16位 | 高8位 | 低8位 | 名称           | 作用                              |
    | ------ | --- | --- | --- | --- | ------------ | ------------------------------- |
    | RAX    | EAX | AX  | AH  | AL  | 累加寄存器        | 数值计算、函数返回                       |
    | RBX    | EBX | BX  | BH  | BL  | 基址寄存器        | 地址索引                            |
    | RCS    | ECS | CX  | CH  | CL  | 计数寄存器        | 循环计数                            |
    | RDX    | EDX | DX  | DH  | DL  | 数据寄存器        | 数据传递                            |
    | RSI    | ESI | SI  |     |     | 源变址寄存器/索引寄存器 | 存放相对于DS段之源变址指针，保存、加载或扫描大量的数据    |
    | RDI    | EDI | DI  |     |     | 目的变址寄存器      | 存放相对于 ES 段之目的变址指针，保存、加载或扫描大量的数据 |
    | RBP    | EBP | BP  |     |     | 基址指针寄存器      | 指向栈中的数据，可用作SS的一个相对基址位置          |
    | RSP    | ESP | SP  |     |     | 堆栈指针         | 与SS配合使用，可指向活动堆栈顶部。              |
    | R8-R15 |     |     |     |     |              |                                 |
-   段寄存器（Segment Register）
    | 32位 | 16位 | 名称     |
    | --- | --- | ------ |
    | CS  | CS  | 代码段寄存器 |
    | DS  | DS  | 数据段寄存器 |
    | ES  | ES  | 堆栈段寄存器 |
    | SS  | SS  | 附加段寄存器 |
    | FD  |     |        |
    | GS  |     |        |
-   指令指针寄存器（Instruction Pointer Register）
    | 64位 | 32位 | 16位 | 名称          | 作用                 |
    | --- | --- | --- | ----------- | ------------------ |
    | RIP | EIP | IP  | 扩展板的指令指针寄存器 | 获取、解码并执行的指令。（自动调整） |
-   标志寄存器(Flags Register)
    | 64位    | 32位    | 16位   | 名称        | 作用       |
    | ------ | ------ | ----- | --------- | -------- |
    | RFLAGS | EFLAGS | FLAGS | 状态与控制寄存器。 | 不应该直接修改。 |
-   方向标志寄存器（DF）

    作用：它用于控制字符串操作指令中的传输方向
    -   清零（设置位0）

        命令：cld

        举例：字符串操作指令将递减（反向）源和目标指针。这意味着数据将从高地址向低地址传输

        作用：在字符串复制操作中，数据将从目标字符串的末尾向起始位置复制。
    -   置位（设置位1）

        命令：`std`

        作用：字符串操作指令将递增（正向）源和目标指针。这意味着数据将从低地址向高地址传输。

        举例：在字符串复制操作中，数据将从源字符串的起始位置向末尾复制。

# 标志位

-   说明

    标志位是指表示处理器状态的单个位
-   分类
    -   ZF（零标志位）

        如果结果为零，则设置为1；否则为0。
    -   CF（进位标志位）

        如果无符号数相减产生借位，则设置为1；否则为0。
    -   SF（符号标志位）

        如果结果为负数，则设置为1；否则为0。
    -   OF（溢出标志位）

        如果有符号数相减产生溢出，则设置为1；否则为0。

# 算术

-   除法
    -   格式
        ```6502&#x20;assembly
        div [word/dword] [寄存器/引用地址]
        ;div 长度 除数
        ```
    -   寄存器
        | 除数      | 被除数     | 商   | 余   |
        | ------- | ------- | --- | --- |
        | M8/R8   | ax      | al  | ah  |
        | M16/R16 | dx:ax   | ax  | dx  |
        | M32/R32 | edx:eax | eax | edx |
        | M64/R64 | rdx:rax | rax | rdx |
    -   示例代码：无符号运算、8位
        ```6502&#x20;assembly
            BPB_SecPerTrk: dw 2
            SectorNo: db 18
            
            mov ax, [SectorNo]
            div word [BPB_SecPerTrk]
            ; 商 al=9
            ; 余 ah=0
        ```
    -   示例代码：无符号运算、32位
        ```6502&#x20;assembly
        ;把被除数edx:eax 设置为32
        mov edx, 0
        mov eax, 32

        ; 把除数设置为3
        div 3
        ; 32 /3 = 10r2
        ; 商 eax=ah
        ; 余 edx=2h
        ```
-   加法
    -   带进位加法
        -   说明

            用执行ADC指令时，它会将源操作数的值与目标操作数的值相加，再加上进位标志的值（如果有进位的话），然后将结果存储到目标操作数中。
        -   影响标志位

            零标志位ZF、进位标志位CF
        -   格式

            destination表示要进行相加的目标操作数，而source表示要与目标操作数相加的源操作数。
            ```6502&#x20;assembly
            ADC destination, source
            ```
-   递增
    -   说明

        `dec`是"decrement"（递减）的缩写。它是一条用于将寄存器或内存中的值减一的指令。具体来说，`dec`指令会将操作数的值减一，并将结果存储回原来的位置。
    -   用法
        ```6502&#x20;assembly
        dec byte ptr [eax]  ; 递减存储在eax寄存器指向的内存位置的8位值
        dec word ptr [ebx]  ; 递减存储在ebx寄存器指向的内存位置的16位值
        dec dword ptr [ecx] ; 递减存储在ecx寄存器指向的内存位置的32位值
        ```
    需要注意的是，`dec`指令会影响标志寄存器中的标志位，比如溢出标志（overflow flag）和零标志（zero flag）。

# 位

-   操作
    -   左移

        说明：将累加器 `al` 的值向左移动一位。

        算术：al\*2

        记作：`al<<1`
        -   示例代码
            ```6502&#x20;assembly
            shl al, 1
            ```
    -   右移

        说明：将累加器 `al` 的值向右边移动一位。

        算术：al/2，

        记作：`al>>1`
        -   示例代码
            ```6502&#x20;assembly
            shr al, 1
            ```
-   运算
    -   OR（逻辑或）
        -   作用

            命令执行的操作是将两个操作数的对应位进行逻辑或运算，生成一个结果。如果任何一个位上的操作数为1，那么结果对应的位就是1，否则为0。
        -   格式

            destination和source可以是寄存器、内存位置或立即数
            ```6502&#x20;assembly
            or destination, source
            ```
        -   示例代码
            ```6502&#x20;assembly
            or eax, ebx  ; 将寄存器eax与寄存器ebx进行逻辑或操作，并将结果存储在eax中
            or ecx, 0x12 ; 将寄存器ecx与立即值0x12进行逻辑或操作，并将结果存储在ecx中
            or [esi], dl ; 将内存位置[esi]与寄存器dl进行逻辑或操作，并将结果存储在[esi]中
            ```

# 字符串

-   对比
    -   cmps

        用于比较两个字符串的内容。
-   逐字节加载

    命令：lodsb

    相关命令：lodsw/lodsd/lodsq

    作用：从DS:RSI / DS:ESI / DS:SI寄存器指定的内存地址中读取数据到RAX/EAX/AX寄存器 。

    标志符：如果方向标志位（DF）被设置为0，则SI自动递增；如果DF被设置为1，则SI自动递减
    -   示例代码
        ```6502&#x20;assembly
        section .data
            myString db 'Hello, World!', 0

        section .text
            global _start

        _start:
            ; 设置数据段寄存器
            mov ax, 0x0000
            mov ds, ax

            ; 设置源索引寄存器
            mov si, myString

            ; 使用 lodsb 加载一个字节到 AL 寄存器中
            lodsb

            ; 在这里可以对 AL 寄存器中的值进行处理
            ; 例如，可以将其打印到屏幕上

            ; 退出程序
            mov eax, 1
            xor ebx, ebx
            int 0x80
        ```

# 对比

-   cmp
    -   说明

        `cmp`（比较）指令用于比较两个操作数的值。该指令会将两个操作数相减，并根据结果设置标志寄存器的相应位。
    -   格式

        &#x20;`destination` 和 `source` 是要进行比较的操作数。它们可以是寄存器、内存位置或立即数。
        ```text
        cmp destination, source
        ```
    -   执行过程
        1.  将 `destination` 和 `source` 的值相减，但不保存结果。
        2.  根据减法的结果设置标志寄存器的标志位。这些标志位包括零标志位（ZF）、进位标志位（CF）、符号标志位（SF）、溢出标志位（OF）等。
    -   示例
        ```6502&#x20;assembly
        mov eax, 10     ; 将值10存储到 eax 寄存器
        mov ebx, 20     ; 将值20存储到 ebx 寄存器
        cmp eax, ebx    ; 比较 eax 和 ebx 的值
        ```
        在这个示例中，`cmp` 指令将比较 `eax` 和 `ebx` 寄存器的值。根据比较结果，可以使用条件跳转指令来执行不同的指令路径。

        总结一下，`cmp` 指令用于比较两个操作数的值，并设置标志寄存器的标志位，以便后续的条件跳转或其他操作可以根据比较结果进行决策。

# 循环

-   LOOPNE（zero标志位不等于0）
    -   作用

        用于在满足循环计数器不为零且标志寄存器中的Zero标志位不为0时，重复执行接下来的指令快
    -   格式
        ```6502&#x20;assembly
        label:
            ; 循环体指令
            ; ...

            loopne label
        ```

# 跳转

-   无条件的远跳转: JMP
    ```6502&#x20;assembly
    ;段地址和段内偏移组成
    JMP FAR SECTION:OFFSET
    ```
-   根据 EFLAGS 寄存器的标志位跳转
-   有条件跳转
    -   带符号数与无符号数
        | 标志    | 指令    | 如果xxx，就跳转 |
        | ----- | ----- | --------- |
        | OF=1  | JO    | 溢出        |
        | OF=0  | JNO   | 不溢出       |
        | PF=1  | JP    | 奇偶校验位 置位  |
        | PF=0  | JNP   | 奇偶校验位 不置位 |
        | SF=1  | JS    | 符号位 置位    |
        | SF=0  | JNS   | 符号位 不置位   |
        | ZF=1  | JE    | 相等        |
        | ZF=1  | JZ    | 为0        |
        | ZF=0  | JNE   | 不相等       |
        | ZF=0  | JNZ   | 不为0       |
        | CX=0  | JCXZ  | CX为0      |
        | ECX=0 | JECXZ | ECX为0     |
        | RCX=0 | JRCXZ | RCX为0     |
    -   带符号数
        | 标志               | 指令   | 如果xxx，就跳转 |
        | ---------------- | ---- | --------- |
        | SF != OF         | JL   | 小于        |
        | SF != OF         | JNGE | 不大于或不等于   |
        | SF = OF          | JGE  | 大于或等于     |
        | SF = OF          | JNL  | 不小于       |
        | ZF=1 or SF != OF | JLE  | 小于或等于     |
        | ZF=1 or SF != OF | JNLG | 不大于       |
        | ZF=0 and SF!=OF  | JG   | 大于        |
        | ZF=0 and SF!=OF  | JNLE | 不小于或等于    |
    -   无符号数
        | 标志           | 指令   | 如果xxx，就跳转 |
        | ------------ | ---- | --------- |
        | CF=1         | JB   | 低于        |
        | CF=1         | JC   | 进位标志位置位   |
        | CF=1         | JNAE | 不高于或不等于   |
        | CF=0         | JAE  | 高于或等于     |
        | CF=0         | JNB  | 不低于       |
        | CF=0         | JNC  | 进位标志 不置位  |
        | CF=1 or ZF=1 | JBE  | 低于或等于     |
        | CF=1 or ZF=1 | JNA  | 不高于       |
        | CF=0 or ZF=0 | JA   | 高于        |
        | CF=0 or ZF=0 | JNBE | 不低于或等于    |

# 函数

-   栈
    -   特点

        在调用函数时增长，并在调用结束时结束收缩

        会在推入局部变量时增长，弹出局部变量时收缩

        向下增长（推人栈中的新内容会出现在地址值较低的位置中）
    -   大小

        32 位环境下，栈中的每个元素占据4 个字节

        64位环境下，栈中的每个元素占据8 个字节
    -   组成部分
        -   栈帧（Stack Frame）
            -   定义

                栈帧是在函数调用期间在栈中分配的一块内存区域。
            -   创建

                每当函数被调用时，会自动创建一个新的栈帧，会被压入栈中。
            -   目的

                保存局部变量和必要的上下文
            -   寄存器
                -   SP

                    定义：是一个指向栈顶的指针寄存器。它指向当前栈帧的顶部，即栈中最后一个压入的数据的位置。

                    作用：SP主要用于栈的操作，如推入和弹出数据。当需要将数据压入栈时，可以使用SP来计算新数据的位置，并将SP递减以指向新的栈顶。当需要弹出数据时，可以使用SP来访问当前栈顶的数据，并将SP递增以指向下一个数据。

                    作用：分配局部变量（方式：减小栈指针SP的值来分配）

                    注意：在函数调用过程中，SP的值会随着数据的推入和弹出而变化，以维护栈的正确状态
                -   BP

                    定义：是一个用于定位当前栈帧的基址寄存器。它通常指向当前函数栈帧的底部，也就是栈帧中的参数和局部变量的起始位置。

                    作用：用于访问函数的参数和局部变量。通过偏移量和BP的值，可以访问相对于当前栈帧的参数和局部变量的位置。

                    注意：在函数调用过程中，BP的值通常会被保存到栈中，以便在函数返回时恢复上一个函数的栈帧。
            -   组成部分
                -   参数（Arguments）

                    函数调用时传递给函数的参数通常会被存储在栈帧中。参数可以通过相对于栈帧基址（SP寄存器）的偏移量来访问。
            -   位置

                栈帧顶部：由SP确定

                栈帧底部：由BP确定

                栈帧在内存中的位置是通过栈指针（SP）和基址指针（BP）来确定的。具体的位置计算方式取决于采用的编程约定和机器架构。

                在一般情况下，栈帧的位置相对于基址指针（BP）来进行偏移计算。基址指针（BP）通常指向当前栈帧的底部，也就是栈帧中的参数和局部变量的起始位置。

                以下是一个示例，展示了在x86架构下，使用基址指针（BP）和栈指针（SP）来计算栈帧中的位置偏移量：
                ```6502&#x20;assembly
                push bp         ; 将上一个函数的基址指针推入栈中
                mov bp, sp      ; 将栈指针的值赋给基址指针，建立当前栈帧

                sub sp, 16      ; 为局部变量分配16字节的空间，栈指针减去16

                mov dword [bp-8], 10    ; 将值10存储到基址指针偏移量为-8的位置
                mov word [bp+4], 20     ; 将值20存储到基址指针偏移量为4的位置

                ```
                在上述示例中，通过`mov bp, sp`语句，将栈指针（SP）的值赋给基址指针（BP），建立了当前栈帧。然后，使用基址指针（BP）和偏移量来访问栈帧中的位置。例如，`mov dword [bp-8], 10`将值10存储到基址指针偏移量为-8的位置，而`mov word [bp+4], 20`将值20存储到基址指针偏移量为4的位置。

                需要注意的是，不同的编程约定和机器架构可能会有不同的栈帧布局和偏移计算规则。在编写汇编代码时，应根据目标平台和约定来确定正确的偏移量计算方式。
        -   返回地址（Return Address）

            返回地址是指调用函数后需要继续执行的下一条指令的地址。在函数调用时，返回地址会被推入栈中，以便在函数执行结束后能够返回到正确的位置。
        -   局部变量（Local Variables）

            函数中声明的局部变量也会被分配在栈帧中。局部变量相对于基址指针（BP）的偏移量是负的。
        -   传入参数（可能有）

            函数的局部变量和传入的参数在栈上是相邻存放的，传入的函数参数相对于基址指针（BP）的偏移量是正的。
        -   保存的寄存器（Saved Registers）

            某些寄存器的值在函数调用期间需要被保存，以便在函数返回时能够恢复原始值。这些寄存器的值通常会被保存在栈帧中。
    -   压入
        -   push（单个寄存器）
            -   作用

                将一个值或寄存器中的内容压入堆栈的栈顶，并更新堆栈指针。
            -   示例
                ```6502&#x20;assembly
                mov eax, 42     ; 将值 42 存储在寄存器 eax 中
                push eax        ; 将寄存器 eax 中的值压入堆栈
                ```
    -   弹出
        -   pop（单个寄存器）
        -   popa（多个寄存器，仅x86以下）
            -   作用

                将栈顶的数据弹出并按照以下顺序存储到一组通用寄存器中：EDI、ESI、EBP、ESP、EBX、EDX、ECX、EAX（或相应的16位寄存器）。
            -   注意

                这个指令通常与`pusha`指令配对使用，用于保存和恢复寄存器的状态。通过将寄存器的值推入栈中，然后使用`popa`指令将值从栈中弹出到寄存器中，可以方便地保存和恢复多个寄存器的内容。
-   调用方式
    -   直接调用
        ```6502&#x20;assembly
        CALL 函数名
        ```
    -   远调用
        ```6502&#x20;assembly
        ;段地址和段内偏移组成
        CALL FAR SECTION:OFFSET
        ```
-   返回

    远返回RET：无操作数
    ```纯文本
    RET
    ```
-   示例：传参

    假设有一个名为`add_numbers`的函数，它接受两个整数作为参数，并返回它们的和。
    ```6502&#x20;assembly
    section .text
        global _start

    _start:
        ; 推送第一个参数
        mov eax, 10        ; 第一个参数为10
        push eax           ; 将第一个参数推入栈

        ; 推送第二个参数
        mov eax, 20        ; 第二个参数为20
        push eax           ; 将第二个参数推入栈

        ; 调用add_numbers函数
        call add_numbers

        ; 清理栈上的参数
        add esp, 8         ; 清理推入栈的两个参数（每个参数4个字节）

        ; 程序终止
        mov eax, 1         ; 退出系统调用号
        xor ebx, ebx       ; 返回值为0
        int 0x80           ; 执行系统调用

    ; 函数体
    add_numbers:
        mov ebx, [esp+4]   ; 第一个参数在esp+4的位置
        mov ecx, [esp+8]   ; 第二个参数在esp+8的位置
        add ebx, ecx       ; 将两个参数相加
        ret                ; 返回
    ```
    在上面的示例中，假设函数的参数为32位整数。首先，我们将第一个参数10赋给寄存器eax，并使用`push`指令将其推入栈。然后，我们将第二个参数20赋给eax，并再次使用`push`指令将其推入栈。接下来，我们使用`call`指令调用`add_numbers`函数。在函数内部，我们使用`mov`指令将栈中的参数加载到寄存器ebx和ecx中，并使用`add`指令将它们相加。最后，我们使用`ret`指令返回到调用者。

    在函数返回后，我们需要清理栈上推入的参数，以确保栈指针恢复到正确的位置。在示例中，我们使用`add`指令将栈指针esp增加8个字节，以清理两个参数（每个参数占4个字节）。最后，我们执行系统调用来终止程序。

    需要注意的是，不同的汇编语言和架构可能有不同的参数传递约定和调用约定。上述示例是基于x86架构和Linux操作系统的示例。在其他情况下，可能会使用不同的寄存器或栈结构来传递参数。因此，在编写汇编代码时，应该根据目标平台和约定进行适当的调整。

# 占位

-   nop

    作用：为了填充指令序列或者用作占位符，以保持程序的结构或满足特定的要求。循环中插入nop指令以延迟循环的执行。

# IO端口

-   insb（从IO端口读取数据）
    -   作用

        用于从I/O端口读取一个字节数据，并将其存储到ES段寄存器指向的内存地址中。
    -   示例代码

        是从DX指定的I/O端口读取一个字节的数据，并将其存储到ES:DI指定的内存地址中。该指令用于输入字符串操作，常用于从设备读取数据或接收输入。
        ```6502&#x20;assembly
        insb byte ptr es:[di], dx

        ; insb：表示输入字符串（Input String），从I/O端口读取数据。
        ; byte ptr：表示操作数的大小为一个字节。
        ; es:[di]：表示目标内存地址，其中ES段寄存器存储段基址，DI寄存器存储偏移地址。因此，es:[di]表示通过ES:DI提供的内存地址。
        ; dx：表示源I/O端口的地址，其中DX寄存器存储I/O端口的地址。

        ```
-   outsw（从CPU到I/O端口）
    -   说明

        用于将字符串数据从CPU的数据段（DS:ESI）复制到由DX寄存器指定的I/O端口。
        outs\`指令将从内存中指定的源操作数地址开始的连续字数据复制到由DX寄存器中指定的I/O端口。每个字节数据都会被依次输出到I/O端口，并且DX的值会自动递增，以便指向下一个I/O端口。
    -   格式
        ```bash
        outsw
        ```
    -   注意

        只能用于特权级为0的程序或内核代码中，因为它涉及到与I/O设备的直接交互，而这通常需要操作系统或内核的特权级别。
