不输出错误

```
2> /dev/null
```

静默输出

```
>/dev/null 2>&1
```

将所有输出，重定向到文本

```
>test.txt 2>&1
```



shell上:
0表示标准输入
1表示标准输出
2表示标准错误输出
\> 默认为标准输出重定向，与 1> 相同
2>&1 意思是把 标准错误输出 重定向到 标准输出.
&>file 意思是把 标准输出 和 标准错误输出 都重定向到文件file中

用例子说话：

\1. grep da * 1>&2 
\2. rm -f $(find / -name core) &> /dev/null
上面两例中的 & 如何理解，&不是放到后台执行吗?

牛解：
1.&>file或n>&m均是一个独立的重定向符号，不要分开来理解。
2.明确文件和文件描述符的区别。
3.&>file表示重定向标准输出和错误到文件
例如：
rm -f $(find / -name core) &> /dev/null，/dev/null是一个文件，这个文件比较特殊，所有传给它的东西它都丢弃掉。
4.n>&m表示使文件描述符n成为输出文件描述符m的副本。这样做的好处是，有的时候你查找文件的时候很容易产生无用的信息,如:2> /dev/null的作用就是不显示标准错误输出；另外当你运行某些命令的时候,出错信息也许很重要,便于你检查是哪出了毛病,如:2>&1
