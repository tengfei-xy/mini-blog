> 问题1：如何确定内存使用了大页面还是巨型页。
>

# Windows 内存

## 任务管理器指标说明

**内存使用量：**为物理内存使用量，但不包括设备的内容。12.6GB为内存物理总量

**使用中（已压缩）：**由进程、驱动程序或操作系统使用的物理内存

**可用：**实际内存物理量，当前未使用但会在进程、驱动程序或操作系统需要更多内存时首先重新使用的内存。等于备用、可用、零页面的大小总和。

**已提交：**15.1GB为虚拟内存的最大值，5.2GB为虚拟内存使用中。

**已缓存：**系统缓存内存量(备用列表的大小以及系统工作集综合：Cache Bytes、Modified Page List Bytes、StandBy Cache Core Bytes、Standby Cache Normal Priority Bytes、StandBy Cache Reserve Bytes的总和)

**分页缓冲池：**分页池的总大小，包括空闲和已分配的区域

**非分页缓冲池：**非分页池的总大小，包括空闲和已分配的区域

**备用：**包含未频繁使用的缓存数据和代码的内存





## 页面

### 页面类型

**小页面：**

默认4KB

**大页面（large gage）：**

大页面2MB，一个大页面等于512个小页面。大页面的优势在于地址转译速度更快。

在系统长时间运行后，大型页内存区域可能很难获取，因为每个大型页面的物理空间必须连续，但内存可能已碎片化。 在这些条件下分配大型页面可能会导致大页面分配失败显著影响系统性能。 

> 大页面需要处理器支持。参考[GetLargePageMinimun函数的MEM_LARGE_PAGES标志](https://learn.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-getlargepageminimum)
>
> 设置大页面内存，参考[Large-Page支持](https://learn.microsoft.com/zh-cn/windows/win32/memory/large-page-support)

**巨型页（huge page）：**

巨型页可达1GB，如果分配的请求大小超过1GB，自动分配巨型页。

### 页面状态

页面是**空闲的（free）**、**保留的（reserved）**、**提交的（committed）**、或是**共享的（shareable）**。

**共享的页面：**他们在被访问时，最终会被转移到物理内存的有效页面。并且是其他进程共有的。

**提交的页面：**是进程私有的页面，首次访问时以零初始化页面的方式创建出来。

**保留的页面：**设置一段连续的虚拟地址以供日后使用，并只占一丢丢丢资源，等待真正需要使用时再提交。。试图访问这部分内存将导致异常。

> 1. ReadProcessMemory函数和WriteProcessMemory函数允许跨进程访问。他们需要满足俩者之一的条件，目标进程的安全描述符被授予PROCESS_VM_READ或PROCESS_VM_WRITE权限，或者拥有SeDebugPrivilege特权，它默认值授予Administrators组的成员。
> 2. 解除提交后的内存依然是被保留的，释放内存是空闲的、自由的。
> 3. [保留页面和提交页面的对比实验](./保留页面和提交页面.md)



## 内核模式的换页池和非换页池

对于非换页池和换页池都位于系统地址空间，可以映射到每个进程的虚拟地址空间。

非换页池：

在任何时间总是驻留在物理内存中的虚拟地址组成，不产生任何页面错误。

> 意义：可以从任何IRQL访问
>
> 必要性：任何代码和数据如果需要在[DPC](https://zh.wikipedia.org/wiki/延迟过程调用)/dispatch级别或更高级别上执行或访问，都必须位于非换页内存池中，因为在此级别中页面错误无法被满足

换页池：

可以换入或换出系统。换页池可以从任何进程访问。

> 如果设备驱动程序无需从[DPC](https://zh.wikipedia.org/wiki/延迟过程调用)/dispatch级别或更高级别上执行或访问，即可使用换页池

## 堆

Windows10 有俩种堆，一种是NT堆，一种是段堆（被UWP应用和某些系统进程使用）。用户模式的NT堆由堆前端和堆后端组成，其中堆后端包括堆的基本功能：段内部内存块管理、段管理、堆扩展策略、内存提交和内存接触以及大块管理。

## 虚拟内存

Windows进程运行于私有的空间地址，该空间地址是线性的，并映射于物理内存（内存管理器作用1）上，因此该空间叫做虚拟内存。



当进程需要用到更多的内存（超过物理内存）时，内存管理器（ntoskrnl.exe）会将内存的部分内容或者放（英文动词：page）到磁盘中。于是就可以释放这部分物理内存。当进程需要访问已经被放到硬盘中的内存时，内存管理器会将这部分信息放回内存中（内存管理器作用2）。在硬件的支持下，应用程序无需额外操作和内存管理器无需进程协助。

> 在系统属性（sysdm.cpl）中，能够设置虚拟内存（页面文件）。但页面文件是虚拟内存的一个方面，即使不使用页面文件，也仍然使用虚拟内存。
>
> 获取方法-cmd
>
> Systeminfo

虚拟地址空间以页面为单位，

> 进程默认是4KB的，最大的虚拟地址空间不仅取决于系统版本，还取决于进程的体系结构。32位的程序默认2G，64位默认128TB。因此当进程所需的内存超过2G时，应该编译位64位，以此减少内核虚拟分配机制管理系统地址空间的成本。
>
> 64位的地址最高访问16EB的虚拟空间，但由于CPU和系统内核的限制，目前只实现到128TB。

虚拟地址空间中的提交量：表示系统中所有虚拟内存的总量

虚拟地址空间的基本布局结构:

虚拟地址有三个类型的数据被映射到此空间，分别是每个进程和会话空间、系统空间的代码和数据。

进程：每个进程都有一个私有的地址空间。存储虚拟地址空间的信息是页表（page table），每个进程均有页表集合，只有从内核模式才能反问，用户模式的线程无法修改。

> 进程不允许访问私有地址以外的虚拟地址。共享内存是通过进程内的地址来访问，跨进程内存函数是有进程的内核模式代码来操作的。

会话空间：针对会话的全局信息。会话有进程和系统对象组成，代表了用户的一个登录会话。每个会话都有一个专门的换页池区域。当进程被创建的时候，这一地址范围被映射到进程所属会话的页面上。

系统空间：包含了全局的操作系统代码和数据结构。他们对于所有的进程都是可见的。由系统代码、非换页内存池、换页内存池、系统缓存、系统页表项（PTE）、系统工作集列表、系统映射的视图、超空间、崩溃转储信息、HAL构成。

> 系统页表项可以由性能工具检查“Memory: Free System Page Table Entries”值得到，或由调试器使用`!sysptes`或`!vm`,或转储`_MI_SYSTEM_PTE_TYPE`来得到

配额：系统配额位于:计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management

用户地址空间的布局结构：内核地址是动态的，用户地址空间也是动态构建的。线程栈、进程堆和已加载镜像的地址都是已通过地址空间布局随机化（ASLR）的机制来动态计算的。

一个进程所使用的虚拟内存的详细视图包括：映像，私有，可分享，映射文件，堆，栈，系统组成

## 堆管理器

进程虽然可以利用页面来分配内存块，但即使是最小的页面也是4KB，日常程序中对于变量可能才几十字节。因此为了满足这种需求Windows提供了堆管理器（Ntdll.dll和ntoskrnl.exe）来负责大内存区域中的内存分配。

> 当使用C语言的malloc、free以及C++的new是，C运行时（CRT）也支持堆管理器。最常用的Windows对函数如HeapCreate或HeanDestory、HeapAlloc和HeapFree等函数

每个应用程序至少有一个堆：默认的进程堆。该堆在进程的生命周期过程中永远不会删除，默认大小1MB。通过GetProcessHeap函数来获得默认堆。每个进程中包含了一个数组，数组中包含了所有堆信息，利用GetProcessHeaps可以获得。



**结构：**

应用程序为了访问内存，首先访问的是堆管理器（从API到前段堆层（可选）与核心堆层），其次有堆管理器访问内存管理器。

前端堆层：事可选且进针对用户模式的堆。Windows支持的唯一一种前段堆层是低碎片堆（LFH，Low Fragmentation Heap）。

核心堆层：最常见功能为跨用户模式和内核模式的堆实现，核心功能：段内部的内存块管理、段管理、堆的扩展策略、提交内存和解除提交、大块管理。



**堆同步：**

堆管理器支持多个线程并发访问。当堆同步被打开时，每个堆都有一个锁，用来保护堆结构。

当进程是单线程时，可以在创建堆或者每次分配内存是指定HEAP_NO_SERIALIZE来告知堆管理器，避免同步开销

当进程是多线程时，要保持一致性状态操作，需要锁住堆。



## 地址转义

CPU将虚拟地址通过页表（PT）转为物理地址。每个虚拟空间的页面都跟系统空间的结构联系在一起，该结构成为页表项（PTE）。



## 页面文件

windows的页面文件是存于已经被修改，虽然被使用但不得不写到硬盘（取消了映射或处于内存压力而被袖箭）上的文件。页面文件包含了进程虚拟内存和内核虚拟内存。

> 为了安全起见，系统应该配置为当系统停机的时候清除页面文件内容,否则有人能够从物理该机器的话，就能读取数据，方法：在HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management项中设置ClearPageFileAtShutdown=1



> 参考：
>
> 内存管理：https://learn.microsoft.com/zh-cn/windows/win32/memory/memory-management
>
> 深入解析Windows第七版第一卷：https://www.epubit.com/bookDetails?id=UBbf572b9969ab&typeName
